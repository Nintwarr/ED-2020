.TH "Cola< T >" 3 "Domingo, 6 de Diciembre de 2020" "TDA Imagen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Cola< T > \- T\&.D\&.A\&. \fBCola\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <cola\&.h>\fP
.SS "Clases"

.in +1c
.ti -1c
.RI "struct \fBCelda\fP"
.br
.in -1c
.SS "M√©todos p√∫blicos"

.in +1c
.ti -1c
.RI "\fBCola\fP ()"
.br
.RI "Constructor por defecto\&. "
.ti -1c
.RI "\fBCola\fP (const \fBCola\fP< T > &original)"
.br
.RI "Constructor de copias\&. "
.ti -1c
.RI "\fB~Cola\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "\fBCola\fP & \fBoperator=\fP (const \fBCola\fP< T > &otra)"
.br
.RI "Operador de asignaciÛn "
.ti -1c
.RI "bool \fBvacia\fP () const"
.br
.RI "Comprueba si la cola est· vacÌa "
.ti -1c
.RI "T & \fBfrente\fP ()"
.br
.RI "Devuelve el elemento del frente de la cola\&. "
.ti -1c
.RI "const T & \fBfrente\fP () const"
.br
.RI "Devuelve el elemento del frente de una cola constante\&. "
.ti -1c
.RI "void \fBponer\fP (const T &elem)"
.br
.RI "AÒade un elemento al final de la cola\&. "
.ti -1c
.RI "void \fBquitar\fP ()"
.br
.RI "Quita el elemento del frente de la cola\&. "
.ti -1c
.RI "int \fBnum_elementos\fP () const"
.br
.RI "Devuelve el n˙mero de elementos de la cola\&. "
.in -1c
.SS "Atributos privados"

.in +1c
.ti -1c
.RI "\fBCelda\fP * \fBprimera\fP"
.br
.RI "Puntero al primer nodo de la lista\&. "
.ti -1c
.RI "\fBCelda\fP * \fBultima\fP"
.br
.RI "Puntero al ˙ltimo nodo de la lista\&. "
.ti -1c
.RI "int \fBnum_elem\fP"
.br
.RI "N˙mero de elementos de la cola\&. "
.in -1c
.SH "Descripci√≥n detallada"
.PP 

.SS "template<class T>
.br
class Cola< T >"
T\&.D\&.A\&. \fBCola\fP\&. 

Una instancia \fIc\fP del tipo de dato abstracto \fBCola\fP sobre un dominio \fIT\fP es una sucesiÛn finita de elementos del mismo con un funcionamiento \fIFIFO\fP (First In, First Out})\&. En una cola, las operaciones de inserciÛn tienen lugar en uno de los extremos, denominado \fIfinal\fP de la cola, mientras que el borrado y consulta se lleva a cabo en el otro extremo, denominado \fIfrente\fP de la cola\&. Una cola de longitud \fIn\fP la denotamos
.PP
.IP "\(bu" 2
<a1,a2,a3,\&.\&.,an<
.PP
.PP
En esta cola, tendremos acceso ˙nicamente al elemento del \fIFrente\fP, es decir, a \fIa1\fP\&. El borrado o consulta de un elemento ser· sobre \fIa1\fP, mientras que la inserciÛn de un nuevo elemento se har· despuÈs de \fIan\fP (final de la cola)\&.
.PP
Si n=0 diremos que la cola est· vacÌa\&.
.PP
El espacio requerido para el almacenamiento es O(n), donde n es el n˙mero de elementos de la cola\&.
.PP
\fBAutor\fP
.RS 4
J\&. Fdez-Valdivia 
.RE
.PP
\fBFecha\fP
.RS 4
Octubre 2011 
.RE
.PP

.PP
Definici√≥n en la l√≠nea 41 del archivo cola\&.h\&.
.SH "Documentaci√≥n del constructor y destructor"
.PP 
.SS "template<class T > \fBCola\fP< T >::\fBCola\fP (const \fBCola\fP< T > & original)"

.PP
Constructor de copias\&. 
.PP
\fBPar√°metros\fP
.RS 4
\fIoriginal\fP La cola de la que se har· la copia\&. 
.RE
.PP

.PP
Definici√≥n en la l√≠nea 13 del archivo cola\&.cpp\&.
.SH "Documentaci√≥n de las funciones miembro"
.PP 
.SS "template<class T > \fBCola\fP< T > & \fBCola\fP< T >::operator= (const \fBCola\fP< T > & otra)"

.PP
Operador de asignaciÛn 
.PP
\fBPar√°metros\fP
.RS 4
\fIotra\fP La cola que se va a asignar\&. 
.RE
.PP

.PP
Definici√≥n en la l√≠nea 45 del archivo cola\&.cpp\&.
.SS "template<class T > void \fBCola\fP< T >::poner (const T & elem)"

.PP
AÒade un elemento al final de la cola\&. 
.PP
\fBPar√°metros\fP
.RS 4
\fIelem\fP Elemento que se va a aÒadir\&. 
.RE
.PP

.PP
Definici√≥n en la l√≠nea 73 del archivo cola\&.cpp\&.

.SH "Autor"
.PP 
Generado autom√°ticamente por Doxygen para TDA Imagen del c√≥digo fuente\&.
